# 36：[有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

> 中等、数组

1. [审题](#审题)
2. [循环判断法（@[Angus-Liu](https://leetcode-cn.com/angus-liu)）](#循环判断法（@[Angus-Liu](https://leetcode-cn.com/angus-liu)）)

## 审题

题目的规则比较复杂，其实总结下来有三种：

1. 每**行**不能重复。
2. 每**列**不能重复。
3. 每**格**不能重复。

三个规则，就要对应三个判断方法。

## 循环判断法（@[Angus-Liu](https://leetcode-cn.com/angus-liu)）

### 点睛

把握住了规则之后，就可以考虑代码表达了。思想非常好理解，使用三组标志数组，记录出现了的数字，若重复出现，则该数独无效。

判断行、列不能重复的标记数组比较简单：

- 因为是 9 * 9 的矩阵，所以行列的数量都为9。
- 0 - 9 一共有 10 个数组，即每个单元出现的数字的可能有10种。

结合以上两条信息，我们可以得出使用一个 9 * 10 的二维数组来表示行列的重复情况。

判断 3 * 3 的小格内的元素是否的重复的思路也是类似：

- 一共有 9 个 3 * 3 小格。
- 每个单元出现的情况有 10 种。

故也可用一个 9 * 10 的二维数组来表示行格的重复情况。

然后我们需要找到一种将原元素坐标（数独中元素对应的数组位置）转换为标志数组的坐标的方法。检查行列重复情况的坐标问题非常好解决，原元素的行（列）数可直接对应到标志数组的行数上。但是检查格的时候的情况呢？

这里需要一个坐标转换公式，转换公式要求可以完整映射映射坐标即可，并不唯一。

我们这样考虑这个转换公式，我们将数独拆为一条横线：

![](./1.PNG)

这里采用的的公式为 $$i / 3 * 3 + j / 3$$，推到过程思路大概如下，原横向坐标为 0 - 9 要将其 映射为 0 - 3 ，固有$$i / 3$$，然后一共有 3 组，故得到$$i / 3 * 3$$，列上也需要映射，故得到$$i / 3 * 3 + j / 3$$。

### 解法

1. 创建三个标志数组，用来记录数组出现的情况。
2. 遍历数组，边判断，边记录。

### 代码

```java
    public boolean isValidSudoku(char[][] board) {
        // 记录某行，某位数字是否已经被摆放
        boolean[][] row = new boolean[9][10];
        // 记录某列，某位数字是否已经被摆放
        boolean[][] col = new boolean[9][10];
        // 记录某 3x3 宫格内，某位数字是否已经被摆放
        boolean[][] block = new boolean[9][10];
        // 遍历矩阵
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    // 这一步会自动转换基本类型，num即使这个位置出现的数字
                    int num = board[i][j] - '0';
                    // 映射索引到格的标志数组对应的位置。
                    int blockIndex = i / 3 * 3 + j / 3;
                    // 如果这个数字已经出现了，则此数独无效
                    if (row[i][num] || col[j][num] || block[blockIndex][num]) {
                        return false;
                    } else {
                        // 将出现的数字对应的位置置为 true
                        row[i][num] = true;
                        col[j][num] = true;
                        block[blockIndex][num] = true;
                    }
                }
            }
        }
        return true;
    }
```

### 时间空间复杂度分析

时间复杂度：因为只遍历了一遍，故为O(n)

空间复杂度：创建了三个标志数组，故为O(n)

